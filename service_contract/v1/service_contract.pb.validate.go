// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: service_contract/v1/service_contract.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ReportMetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportMetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportMetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportMetadataRequestMultiError, or nil if none found.
func (m *ReportMetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportMetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppName

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReportMetadataRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReportMetadataRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReportMetadataRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetServiceMetadata() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ReportMetadataRequestValidationError{
						field:  fmt.Sprintf("ServiceMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ReportMetadataRequestValidationError{
						field:  fmt.Sprintf("ServiceMetadata[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ReportMetadataRequestValidationError{
					field:  fmt.Sprintf("ServiceMetadata[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ReportMetadataRequestMultiError(errors)
	}

	return nil
}

// ReportMetadataRequestMultiError is an error wrapping multiple validation
// errors returned by ReportMetadataRequest.ValidateAll() if the designated
// constraints aren't met.
type ReportMetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportMetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportMetadataRequestMultiError) AllErrors() []error { return m }

// ReportMetadataRequestValidationError is the validation error returned by
// ReportMetadataRequest.Validate if the designated constraints aren't met.
type ReportMetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportMetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportMetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportMetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportMetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportMetadataRequestValidationError) ErrorName() string {
	return "ReportMetadataRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReportMetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportMetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportMetadataRequestValidationError{}

// Validate checks the field values on ServiceMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceMetadataMultiError, or nil if none found.
func (m *ServiceMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetListeningAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceMetadataValidationError{
						field:  fmt.Sprintf("ListeningAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceMetadataValidationError{
						field:  fmt.Sprintf("ListeningAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceMetadataValidationError{
					field:  fmt.Sprintf("ListeningAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetServiceContract()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ServiceMetadataValidationError{
					field:  "ServiceContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ServiceMetadataValidationError{
					field:  "ServiceContract",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetServiceContract()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ServiceMetadataValidationError{
				field:  "ServiceContract",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ServiceMetadataMultiError(errors)
	}

	return nil
}

// ServiceMetadataMultiError is an error wrapping multiple validation errors
// returned by ServiceMetadata.ValidateAll() if the designated constraints
// aren't met.
type ServiceMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceMetadataMultiError) AllErrors() []error { return m }

// ServiceMetadataValidationError is the validation error returned by
// ServiceMetadata.Validate if the designated constraints aren't met.
type ServiceMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceMetadataValidationError) ErrorName() string { return "ServiceMetadataValidationError" }

// Error satisfies the builtin error interface
func (e ServiceMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceMetadataValidationError{}

// Validate checks the field values on ReportMetadataReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReportMetadataReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReportMetadataReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReportMetadataReplyMultiError, or nil if none found.
func (m *ReportMetadataReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ReportMetadataReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ReportMetadataReplyMultiError(errors)
	}

	return nil
}

// ReportMetadataReplyMultiError is an error wrapping multiple validation
// errors returned by ReportMetadataReply.ValidateAll() if the designated
// constraints aren't met.
type ReportMetadataReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReportMetadataReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReportMetadataReplyMultiError) AllErrors() []error { return m }

// ReportMetadataReplyValidationError is the validation error returned by
// ReportMetadataReply.Validate if the designated constraints aren't met.
type ReportMetadataReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReportMetadataReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReportMetadataReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReportMetadataReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReportMetadataReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReportMetadataReplyValidationError) ErrorName() string {
	return "ReportMetadataReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ReportMetadataReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReportMetadataReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReportMetadataReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReportMetadataReplyValidationError{}

// Validate checks the field values on ServiceContract with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceContract) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceContract with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceContractMultiError, or nil if none found.
func (m *ServiceContract) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceContract) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetServices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceContractValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceContractValidationError{
						field:  fmt.Sprintf("Services[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceContractValidationError{
					field:  fmt.Sprintf("Services[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTypes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceContractValidationError{
						field:  fmt.Sprintf("Types[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceContractValidationError{
						field:  fmt.Sprintf("Types[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceContractValidationError{
					field:  fmt.Sprintf("Types[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServiceContractMultiError(errors)
	}

	return nil
}

// ServiceContractMultiError is an error wrapping multiple validation errors
// returned by ServiceContract.ValidateAll() if the designated constraints
// aren't met.
type ServiceContractMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceContractMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceContractMultiError) AllErrors() []error { return m }

// ServiceContractValidationError is the validation error returned by
// ServiceContract.Validate if the designated constraints aren't met.
type ServiceContractValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceContractValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceContractValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceContractValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceContractValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceContractValidationError) ErrorName() string { return "ServiceContractValidationError" }

// Error satisfies the builtin error interface
func (e ServiceContractValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceContract.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceContractValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceContractValidationError{}

// Validate checks the field values on ServiceDescriptor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServiceDescriptor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceDescriptor with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServiceDescriptorMultiError, or nil if none found.
func (m *ServiceDescriptor) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceDescriptor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetMethods() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceDescriptorValidationError{
						field:  fmt.Sprintf("Methods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceDescriptorValidationError{
						field:  fmt.Sprintf("Methods[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceDescriptorValidationError{
					field:  fmt.Sprintf("Methods[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if len(errors) > 0 {
		return ServiceDescriptorMultiError(errors)
	}

	return nil
}

// ServiceDescriptorMultiError is an error wrapping multiple validation errors
// returned by ServiceDescriptor.ValidateAll() if the designated constraints
// aren't met.
type ServiceDescriptorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceDescriptorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceDescriptorMultiError) AllErrors() []error { return m }

// ServiceDescriptorValidationError is the validation error returned by
// ServiceDescriptor.Validate if the designated constraints aren't met.
type ServiceDescriptorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceDescriptorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceDescriptorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceDescriptorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceDescriptorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceDescriptorValidationError) ErrorName() string {
	return "ServiceDescriptorValidationError"
}

// Error satisfies the builtin error interface
func (e ServiceDescriptorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceDescriptor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceDescriptorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceDescriptorValidationError{}

// Validate checks the field values on MethodDescriptor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MethodDescriptor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MethodDescriptor with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MethodDescriptorMultiError, or nil if none found.
func (m *MethodDescriptor) ValidateAll() error {
	return m.validate(true)
}

func (m *MethodDescriptor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if m.ClientStreaming != nil {
		// no validation rules for ClientStreaming
	}

	if m.ServerStreaming != nil {
		// no validation rules for ServerStreaming
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if len(errors) > 0 {
		return MethodDescriptorMultiError(errors)
	}

	return nil
}

// MethodDescriptorMultiError is an error wrapping multiple validation errors
// returned by MethodDescriptor.ValidateAll() if the designated constraints
// aren't met.
type MethodDescriptorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MethodDescriptorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MethodDescriptorMultiError) AllErrors() []error { return m }

// MethodDescriptorValidationError is the validation error returned by
// MethodDescriptor.Validate if the designated constraints aren't met.
type MethodDescriptorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MethodDescriptorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MethodDescriptorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MethodDescriptorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MethodDescriptorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MethodDescriptorValidationError) ErrorName() string { return "MethodDescriptorValidationError" }

// Error satisfies the builtin error interface
func (e MethodDescriptorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMethodDescriptor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MethodDescriptorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MethodDescriptorValidationError{}

// Validate checks the field values on ServiceOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServiceOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServiceOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServiceOptionsMultiError,
// or nil if none found.
func (m *ServiceOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *ServiceOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServiceOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServiceOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServiceOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Deprecated != nil {
		// no validation rules for Deprecated
	}

	if len(errors) > 0 {
		return ServiceOptionsMultiError(errors)
	}

	return nil
}

// ServiceOptionsMultiError is an error wrapping multiple validation errors
// returned by ServiceOptions.ValidateAll() if the designated constraints
// aren't met.
type ServiceOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceOptionsMultiError) AllErrors() []error { return m }

// ServiceOptionsValidationError is the validation error returned by
// ServiceOptions.Validate if the designated constraints aren't met.
type ServiceOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceOptionsValidationError) ErrorName() string { return "ServiceOptionsValidationError" }

// Error satisfies the builtin error interface
func (e ServiceOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServiceOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceOptionsValidationError{}

// Validate checks the field values on MethodOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MethodOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MethodOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MethodOptionsMultiError, or
// nil if none found.
func (m *MethodOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *MethodOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MethodOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MethodOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MethodOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Deprecated != nil {
		// no validation rules for Deprecated
	}

	if len(errors) > 0 {
		return MethodOptionsMultiError(errors)
	}

	return nil
}

// MethodOptionsMultiError is an error wrapping multiple validation errors
// returned by MethodOptions.ValidateAll() if the designated constraints
// aren't met.
type MethodOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MethodOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MethodOptionsMultiError) AllErrors() []error { return m }

// MethodOptionsValidationError is the validation error returned by
// MethodOptions.Validate if the designated constraints aren't met.
type MethodOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MethodOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MethodOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MethodOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MethodOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MethodOptionsValidationError) ErrorName() string { return "MethodOptionsValidationError" }

// Error satisfies the builtin error interface
func (e MethodOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMethodOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MethodOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MethodOptionsValidationError{}

// Validate checks the field values on OneofDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OneofDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OneofDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OneofDescriptorProtoMultiError, or nil if none found.
func (m *OneofDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *OneofDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Name != nil {
		// no validation rules for Name
	}

	if len(errors) > 0 {
		return OneofDescriptorProtoMultiError(errors)
	}

	return nil
}

// OneofDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by OneofDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type OneofDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OneofDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OneofDescriptorProtoMultiError) AllErrors() []error { return m }

// OneofDescriptorProtoValidationError is the validation error returned by
// OneofDescriptorProto.Validate if the designated constraints aren't met.
type OneofDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OneofDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OneofDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OneofDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OneofDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OneofDescriptorProtoValidationError) ErrorName() string {
	return "OneofDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e OneofDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOneofDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OneofDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OneofDescriptorProtoValidationError{}

// Validate checks the field values on TypeDescriptor with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TypeDescriptor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TypeDescriptor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TypeDescriptorMultiError,
// or nil if none found.
func (m *TypeDescriptor) ValidateAll() error {
	return m.validate(true)
}

func (m *TypeDescriptor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetFields() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TypeDescriptorValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TypeDescriptorValidationError{
						field:  fmt.Sprintf("Fields[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TypeDescriptorValidationError{
					field:  fmt.Sprintf("Fields[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetReservedRange() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TypeDescriptorValidationError{
						field:  fmt.Sprintf("ReservedRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TypeDescriptorValidationError{
						field:  fmt.Sprintf("ReservedRange[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TypeDescriptorValidationError{
					field:  fmt.Sprintf("ReservedRange[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Options != nil {

		if all {
			switch v := interface{}(m.GetOptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TypeDescriptorValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TypeDescriptorValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TypeDescriptorValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TypeDescriptorMultiError(errors)
	}

	return nil
}

// TypeDescriptorMultiError is an error wrapping multiple validation errors
// returned by TypeDescriptor.ValidateAll() if the designated constraints
// aren't met.
type TypeDescriptorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TypeDescriptorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TypeDescriptorMultiError) AllErrors() []error { return m }

// TypeDescriptorValidationError is the validation error returned by
// TypeDescriptor.Validate if the designated constraints aren't met.
type TypeDescriptorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TypeDescriptorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TypeDescriptorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TypeDescriptorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TypeDescriptorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TypeDescriptorValidationError) ErrorName() string { return "TypeDescriptorValidationError" }

// Error satisfies the builtin error interface
func (e TypeDescriptorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTypeDescriptor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TypeDescriptorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TypeDescriptorValidationError{}

// Validate checks the field values on EnumDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnumDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnumDescriptorProtoMultiError, or nil if none found.
func (m *EnumDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValue() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  fmt.Sprintf("Value[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnumDescriptorProtoValidationError{
					field:  fmt.Sprintf("Value[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Options != nil {

		if all {
			switch v := interface{}(m.GetOptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnumDescriptorProtoValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnumDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnumDescriptorProtoMultiError(errors)
	}

	return nil
}

// EnumDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by EnumDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type EnumDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumDescriptorProtoMultiError) AllErrors() []error { return m }

// EnumDescriptorProtoValidationError is the validation error returned by
// EnumDescriptorProto.Validate if the designated constraints aren't met.
type EnumDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumDescriptorProtoValidationError) ErrorName() string {
	return "EnumDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e EnumDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumDescriptorProtoValidationError{}

// Validate checks the field values on EnumValueDescriptorProto with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EnumValueDescriptorProto) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumValueDescriptorProto with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnumValueDescriptorProtoMultiError, or nil if none found.
func (m *EnumValueDescriptorProto) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumValueDescriptorProto) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Number != nil {
		// no validation rules for Number
	}

	if m.Options != nil {

		if all {
			switch v := interface{}(m.GetOptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnumValueDescriptorProtoValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnumValueDescriptorProtoValidationError{
						field:  "Options",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnumValueDescriptorProtoValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnumValueDescriptorProtoMultiError(errors)
	}

	return nil
}

// EnumValueDescriptorProtoMultiError is an error wrapping multiple validation
// errors returned by EnumValueDescriptorProto.ValidateAll() if the designated
// constraints aren't met.
type EnumValueDescriptorProtoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumValueDescriptorProtoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumValueDescriptorProtoMultiError) AllErrors() []error { return m }

// EnumValueDescriptorProtoValidationError is the validation error returned by
// EnumValueDescriptorProto.Validate if the designated constraints aren't met.
type EnumValueDescriptorProtoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumValueDescriptorProtoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumValueDescriptorProtoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumValueDescriptorProtoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumValueDescriptorProtoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumValueDescriptorProtoValidationError) ErrorName() string {
	return "EnumValueDescriptorProtoValidationError"
}

// Error satisfies the builtin error interface
func (e EnumValueDescriptorProtoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumValueDescriptorProto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumValueDescriptorProtoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumValueDescriptorProtoValidationError{}

// Validate checks the field values on EnumValueOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnumValueOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnumValueOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnumValueOptionsMultiError, or nil if none found.
func (m *EnumValueOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *EnumValueOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Deprecated != nil {
		// no validation rules for Deprecated
	}

	if len(errors) > 0 {
		return EnumValueOptionsMultiError(errors)
	}

	return nil
}

// EnumValueOptionsMultiError is an error wrapping multiple validation errors
// returned by EnumValueOptions.ValidateAll() if the designated constraints
// aren't met.
type EnumValueOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnumValueOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnumValueOptionsMultiError) AllErrors() []error { return m }

// EnumValueOptionsValidationError is the validation error returned by
// EnumValueOptions.Validate if the designated constraints aren't met.
type EnumValueOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnumValueOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnumValueOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnumValueOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnumValueOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnumValueOptionsValidationError) ErrorName() string { return "EnumValueOptionsValidationError" }

// Error satisfies the builtin error interface
func (e EnumValueOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnumValueOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnumValueOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnumValueOptionsValidationError{}

// Validate checks the field values on MessageOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MessageOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MessageOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MessageOptionsMultiError,
// or nil if none found.
func (m *MessageOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *MessageOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Deprecated != nil {
		// no validation rules for Deprecated
	}

	if len(errors) > 0 {
		return MessageOptionsMultiError(errors)
	}

	return nil
}

// MessageOptionsMultiError is an error wrapping multiple validation errors
// returned by MessageOptions.ValidateAll() if the designated constraints
// aren't met.
type MessageOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MessageOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MessageOptionsMultiError) AllErrors() []error { return m }

// MessageOptionsValidationError is the validation error returned by
// MessageOptions.Validate if the designated constraints aren't met.
type MessageOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MessageOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MessageOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MessageOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MessageOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MessageOptionsValidationError) ErrorName() string { return "MessageOptionsValidationError" }

// Error satisfies the builtin error interface
func (e MessageOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMessageOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MessageOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MessageOptionsValidationError{}

// Validate checks the field values on FieldDescriptor with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FieldDescriptor) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldDescriptor with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FieldDescriptorMultiError, or nil if none found.
func (m *FieldDescriptor) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldDescriptor) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Number

	// no validation rules for Type

	if m.Label != nil {
		// no validation rules for Label
	}

	if m.TypeName != nil {
		// no validation rules for TypeName
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if len(errors) > 0 {
		return FieldDescriptorMultiError(errors)
	}

	return nil
}

// FieldDescriptorMultiError is an error wrapping multiple validation errors
// returned by FieldDescriptor.ValidateAll() if the designated constraints
// aren't met.
type FieldDescriptorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldDescriptorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldDescriptorMultiError) AllErrors() []error { return m }

// FieldDescriptorValidationError is the validation error returned by
// FieldDescriptor.Validate if the designated constraints aren't met.
type FieldDescriptorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldDescriptorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldDescriptorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldDescriptorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldDescriptorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldDescriptorValidationError) ErrorName() string { return "FieldDescriptorValidationError" }

// Error satisfies the builtin error interface
func (e FieldDescriptorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldDescriptor.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldDescriptorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldDescriptorValidationError{}

// Validate checks the field values on FieldOptions with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FieldOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FieldOptions with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FieldOptionsMultiError, or
// nil if none found.
func (m *FieldOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *FieldOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUninterpretedOption() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FieldOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FieldOptionsValidationError{
						field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FieldOptionsValidationError{
					field:  fmt.Sprintf("UninterpretedOption[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Deprecated != nil {
		// no validation rules for Deprecated
	}

	if len(errors) > 0 {
		return FieldOptionsMultiError(errors)
	}

	return nil
}

// FieldOptionsMultiError is an error wrapping multiple validation errors
// returned by FieldOptions.ValidateAll() if the designated constraints aren't met.
type FieldOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FieldOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FieldOptionsMultiError) AllErrors() []error { return m }

// FieldOptionsValidationError is the validation error returned by
// FieldOptions.Validate if the designated constraints aren't met.
type FieldOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FieldOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FieldOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FieldOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FieldOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FieldOptionsValidationError) ErrorName() string { return "FieldOptionsValidationError" }

// Error satisfies the builtin error interface
func (e FieldOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFieldOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FieldOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FieldOptionsValidationError{}

// Validate checks the field values on Node with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Node) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Node with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in NodeMultiError, or nil if none found.
func (m *Node) ValidateAll() error {
	return m.validate(true)
}

func (m *Node) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIdentifier()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeValidationError{
					field:  "Identifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeValidationError{
					field:  "Identifier",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIdentifier()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeValidationError{
				field:  "Identifier",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Locality != nil {

		if all {
			switch v := interface{}(m.GetLocality()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "Locality",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NodeValidationError{
						field:  "Locality",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLocality()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NodeValidationError{
					field:  "Locality",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Tag != nil {
		// no validation rules for Tag
	}

	if m.Cluster != nil {
		// no validation rules for Cluster
	}

	if m.Env != nil {
		// no validation rules for Env
	}

	if len(errors) > 0 {
		return NodeMultiError(errors)
	}

	return nil
}

// NodeMultiError is an error wrapping multiple validation errors returned by
// Node.ValidateAll() if the designated constraints aren't met.
type NodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeMultiError) AllErrors() []error { return m }

// NodeValidationError is the validation error returned by Node.Validate if the
// designated constraints aren't met.
type NodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeValidationError) ErrorName() string { return "NodeValidationError" }

// Error satisfies the builtin error interface
func (e NodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeValidationError{}

// Validate checks the field values on NodeIdentifier with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeIdentifier) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeIdentifier with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeIdentifierMultiError,
// or nil if none found.
func (m *NodeIdentifier) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeIdentifier) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostName

	// no validation rules for Pid

	if all {
		switch v := interface{}(m.GetStartTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeIdentifierValidationError{
					field:  "StartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeIdentifierValidationError{
					field:  "StartTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeIdentifierValidationError{
				field:  "StartTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NodeIdentifierMultiError(errors)
	}

	return nil
}

// NodeIdentifierMultiError is an error wrapping multiple validation errors
// returned by NodeIdentifier.ValidateAll() if the designated constraints
// aren't met.
type NodeIdentifierMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeIdentifierMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeIdentifierMultiError) AllErrors() []error { return m }

// NodeIdentifierValidationError is the validation error returned by
// NodeIdentifier.Validate if the designated constraints aren't met.
type NodeIdentifierValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeIdentifierValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeIdentifierValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeIdentifierValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeIdentifierValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeIdentifierValidationError) ErrorName() string { return "NodeIdentifierValidationError" }

// Error satisfies the builtin error interface
func (e NodeIdentifierValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeIdentifier.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeIdentifierValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeIdentifierValidationError{}

// Validate checks the field values on SocketAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SocketAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SocketAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SocketAddressMultiError, or
// nil if none found.
func (m *SocketAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *SocketAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for PortValue

	if len(errors) > 0 {
		return SocketAddressMultiError(errors)
	}

	return nil
}

// SocketAddressMultiError is an error wrapping multiple validation errors
// returned by SocketAddress.ValidateAll() if the designated constraints
// aren't met.
type SocketAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SocketAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SocketAddressMultiError) AllErrors() []error { return m }

// SocketAddressValidationError is the validation error returned by
// SocketAddress.Validate if the designated constraints aren't met.
type SocketAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SocketAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SocketAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SocketAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SocketAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SocketAddressValidationError) ErrorName() string { return "SocketAddressValidationError" }

// Error satisfies the builtin error interface
func (e SocketAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSocketAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SocketAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SocketAddressValidationError{}

// Validate checks the field values on Locality with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Locality) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Locality with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LocalityMultiError, or nil
// if none found.
func (m *Locality) ValidateAll() error {
	return m.validate(true)
}

func (m *Locality) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Region

	// no validation rules for Zone

	if len(errors) > 0 {
		return LocalityMultiError(errors)
	}

	return nil
}

// LocalityMultiError is an error wrapping multiple validation errors returned
// by Locality.ValidateAll() if the designated constraints aren't met.
type LocalityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LocalityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LocalityMultiError) AllErrors() []error { return m }

// LocalityValidationError is the validation error returned by
// Locality.Validate if the designated constraints aren't met.
type LocalityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LocalityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LocalityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LocalityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LocalityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LocalityValidationError) ErrorName() string { return "LocalityValidationError" }

// Error satisfies the builtin error interface
func (e LocalityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLocality.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LocalityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LocalityValidationError{}

// Validate checks the field values on UninterpretedOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninterpretedOption) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninterpretedOption with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninterpretedOptionMultiError, or nil if none found.
func (m *UninterpretedOption) ValidateAll() error {
	return m.validate(true)
}

func (m *UninterpretedOption) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetName() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UninterpretedOptionValidationError{
						field:  fmt.Sprintf("Name[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UninterpretedOptionValidationError{
						field:  fmt.Sprintf("Name[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UninterpretedOptionValidationError{
					field:  fmt.Sprintf("Name[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.IdentifierValue != nil {
		// no validation rules for IdentifierValue
	}

	if m.PositiveIntValue != nil {
		// no validation rules for PositiveIntValue
	}

	if m.NegativeIntValue != nil {
		// no validation rules for NegativeIntValue
	}

	if m.DoubleValue != nil {
		// no validation rules for DoubleValue
	}

	if m.StringValue != nil {
		// no validation rules for StringValue
	}

	if m.AggregateValue != nil {
		// no validation rules for AggregateValue
	}

	if len(errors) > 0 {
		return UninterpretedOptionMultiError(errors)
	}

	return nil
}

// UninterpretedOptionMultiError is an error wrapping multiple validation
// errors returned by UninterpretedOption.ValidateAll() if the designated
// constraints aren't met.
type UninterpretedOptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninterpretedOptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninterpretedOptionMultiError) AllErrors() []error { return m }

// UninterpretedOptionValidationError is the validation error returned by
// UninterpretedOption.Validate if the designated constraints aren't met.
type UninterpretedOptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninterpretedOptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninterpretedOptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninterpretedOptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninterpretedOptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninterpretedOptionValidationError) ErrorName() string {
	return "UninterpretedOptionValidationError"
}

// Error satisfies the builtin error interface
func (e UninterpretedOptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninterpretedOption.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninterpretedOptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninterpretedOptionValidationError{}

// Validate checks the field values on TypeDescriptor_ReservedRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TypeDescriptor_ReservedRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TypeDescriptor_ReservedRange with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TypeDescriptor_ReservedRangeMultiError, or nil if none found.
func (m *TypeDescriptor_ReservedRange) ValidateAll() error {
	return m.validate(true)
}

func (m *TypeDescriptor_ReservedRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Start != nil {
		// no validation rules for Start
	}

	if m.End != nil {
		// no validation rules for End
	}

	if len(errors) > 0 {
		return TypeDescriptor_ReservedRangeMultiError(errors)
	}

	return nil
}

// TypeDescriptor_ReservedRangeMultiError is an error wrapping multiple
// validation errors returned by TypeDescriptor_ReservedRange.ValidateAll() if
// the designated constraints aren't met.
type TypeDescriptor_ReservedRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TypeDescriptor_ReservedRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TypeDescriptor_ReservedRangeMultiError) AllErrors() []error { return m }

// TypeDescriptor_ReservedRangeValidationError is the validation error returned
// by TypeDescriptor_ReservedRange.Validate if the designated constraints
// aren't met.
type TypeDescriptor_ReservedRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TypeDescriptor_ReservedRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TypeDescriptor_ReservedRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TypeDescriptor_ReservedRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TypeDescriptor_ReservedRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TypeDescriptor_ReservedRangeValidationError) ErrorName() string {
	return "TypeDescriptor_ReservedRangeValidationError"
}

// Error satisfies the builtin error interface
func (e TypeDescriptor_ReservedRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTypeDescriptor_ReservedRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TypeDescriptor_ReservedRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TypeDescriptor_ReservedRangeValidationError{}

// Validate checks the field values on UninterpretedOption_NamePart with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UninterpretedOption_NamePart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UninterpretedOption_NamePart with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UninterpretedOption_NamePartMultiError, or nil if none found.
func (m *UninterpretedOption_NamePart) ValidateAll() error {
	return m.validate(true)
}

func (m *UninterpretedOption_NamePart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NamePart

	// no validation rules for IsExtension

	if len(errors) > 0 {
		return UninterpretedOption_NamePartMultiError(errors)
	}

	return nil
}

// UninterpretedOption_NamePartMultiError is an error wrapping multiple
// validation errors returned by UninterpretedOption_NamePart.ValidateAll() if
// the designated constraints aren't met.
type UninterpretedOption_NamePartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UninterpretedOption_NamePartMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UninterpretedOption_NamePartMultiError) AllErrors() []error { return m }

// UninterpretedOption_NamePartValidationError is the validation error returned
// by UninterpretedOption_NamePart.Validate if the designated constraints
// aren't met.
type UninterpretedOption_NamePartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UninterpretedOption_NamePartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UninterpretedOption_NamePartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UninterpretedOption_NamePartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UninterpretedOption_NamePartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UninterpretedOption_NamePartValidationError) ErrorName() string {
	return "UninterpretedOption_NamePartValidationError"
}

// Error satisfies the builtin error interface
func (e UninterpretedOption_NamePartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUninterpretedOption_NamePart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UninterpretedOption_NamePartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UninterpretedOption_NamePartValidationError{}
